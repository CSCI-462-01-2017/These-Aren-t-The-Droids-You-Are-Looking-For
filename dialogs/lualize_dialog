#!/bin/bash

awk_script=$(mktemp --suffix=".awk")
perl_script=$(mktemp --suffix=".pl")

cat > $awk_script <<-"EOF"
	BEGIN {
		if (prefix != "") prefix = prefix "."
		in_node = 0
		in_code = 0
		in_subdialog = 0
		subdialog = ""
		idx = ""
	}

	/^<FirstTime LuaCode>$/ {
		idx = "firsttime"
		node[idx,"code"] = ""
		in_code = 1
		next
	}

	/^<EveryTime LuaCode>$/ {
	    idx = "everytime"
	    node[idx,"code"] = ""
		in_code = 1
		next
	}

	/^<LuaCode>$/ && (in_node == 1) {
		node[idx,"code"] = ""
		in_code = 1
		next
	}

	/^<\/LuaCode>/ && (in_code == 1) {
		in_code = 0
		in_node = 0
		idx = ""
		next
	}

	function add_code(idx, input) {
		if (node[idx,"code"] == "")
			node[idx,"code"] = input
		else
			node[idx,"code"] = node[idx,"code"] "\n" input
	}
	
	function check_subdialog_call(input)
	{
		pattern = "call_subdialog\\(\"[^\"]+\"\\)"
		if (match(input, pattern)) {
			in_subdialog = 1
			match_start = RSTART
			match_length = RLENGTH
			subdialog = substr(input, match_start + 16, match_length - 16 - 2)
			node[idx,"after"] = subdialog
			add_code(idx,"push_topic(\"" subdialog "\")")
			add_code(idx,"-- call " subdialog " subdialog")
			add_code(idx,"next(\"" subdialog ".everytime\")")
			return 1
		}
		return 0
	}
	
	function replace(input, keyword, skip)
	{
		inline = input
		outline = ""
		pattern = keyword "\\([^)]+\\)"
		if (skip) {
			pattern = keyword "\\([^,]+,[^)]+\\)"
		}
		while (match(inline, pattern)) {
			match_start = RSTART
			match_length = RLENGTH
			outline = outline substr(inline, 1, match_start - 1)

			params = substr(inline, match_start, match_length - 1)
			paren_idx = index(params, "(") + 1
			params = substr(params, paren_idx)

			nb = split(params, nodes, ",[ \t]*")
			if (nb) {
				outline = outline keyword "("
				for (i = 1; i <= nb; i++) {
					if (skip && i == 1) {
						outline = outline nodes[i]
					} else {
						if (match(nodes[i], "^[ ]*[0-9]+$") == 0) {
							outline = outline "\"" prefix "node" "\" .. " nodes[i]
						} else {
							outline = outline "\"" prefix "node" nodes[i] "\""
						}
					}
					if (i != nb)
					  outline = outline ", "
				}
				outline = outline ")"
			}

			inline = substr(inline, match_start + match_length)
		}
		outline = outline inline
		return outline
	}

	(in_code == 1) {
		$0 = replace($0, "hide", 0)
		$0 = replace($0, "show", 0)
		$0 = replace($0, "show_node_if", 1)
		$0 = replace($0, "next", 0)
		gsub("topic\\(", "push_topic(")
		gsub("pop_push_topic", "pop_topic")
		if ( prefix != "" )
			gsub("end_dialog\\(\\)", "next(\"after-" substr(prefix, 1, length(prefix) - 1) "\")")
		
		if (check_subdialog_call($0) == 1)
			next

		if (in_subdialog == 0) {
			add_code(idx, $0)
		} else {
			add_code(subdialog, $0)
		}
	}

	/^Nr=/ {
		line = $0
		comment = ""
		split($0, C, "\"[ \t]*--")
		if ( 2 in C ) {
			line = C[1] "\""
			comment = "  --" C[2]
		}

		if (match(line, "Nr[ \t]*=[ \t]*([[:digit:]]+)", A)) {
			node_def = substr(line, A[1, "start"], A[1, "length"])
			idx = node_def
		} else {
			next
		}

		if (match(line, "Text[ \t]*=[ \t]*(_?\"[^\"]+\")", A)) {
			text_def = substr(line, A[1, "start"], A[1, "length"])
			node[idx,"text"] = text_def
		}

		if (match(line, "Topic[ \t]*=[ \t]*(_?\"[^\"]+\")", A)) {
			topic_def = substr(line, A[1, "start"], A[1, "length"])
			node[idx,"topic"] = topic_def
		}

		node[idx,"comment"] = comment
		node[idx,"disabled"] = 0
		in_node = 1
		in_subdialog = 0
		next
	}

	/^Topic/ && (in_node == 1) {
		line = $0
		split($0, C, "\"[ \t]*--")
		if ( 2 in C ) {
			line = C[1] "\""
			if ( node[idx,"comment"] != "" ) node[idx,"comment"] = node[idx,"comment"] "\n"
			node[idx,"comment"] = node[idx,"comment"] "  --" C[2]
		}

		split(line, topic_def, "=")
		node[idx,"topic"] = topic_def[2]
		next
	}

	/^NO_TEXT$/ && (in_node == 1) {
		node[idx,"no_echo"] = 1
		next
	}

	{  
		next
	}

	END {
		print "---------------------------------------------------------------------"
		print "-- This file is part of Freedroid"
		print "--"
		print "-- Freedroid is free software; you can redistribute it and/or modify"
		print "-- it under the terms of the GNU General Public License as published by"
		print "-- the Free Software Foundation; either version 2 of the License, or"
		print "-- (at your option) any later version."
		print "--"
		print "-- Freedroid is distributed in the hope that it will be useful,"
		print "-- but WITHOUT ANY WARRANTY; without even the implied warranty of"
		print "-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the"
		print "-- GNU General Public License for more details."
		print "--"
		print "-- You should have received a copy of the GNU General Public License"
		print "-- along with Freedroid; see the file COPYING. If not, write to the"
		print "-- Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,"
		print "-- MA 02111-1307 USA"
		print "----------------------------------------------------------------------"
		print ""

		print "return {"

		if ( ("firsttime","code") in node ) {
			if ( prefix == "" ) {
				print "FirstTime = function()"
				print node["firsttime","code"]
				print "  end,\n"
			}
		}

		if ( ("everytime","code") in node ) {
			if ( prefix == "" ) {
				print "EveryTime = function()"
				print node["everytime","code"]
				print "  end,\n"
			} else {
				print "{"
				print "  id = \"" prefix "everytime\","
				print "  code = function()"
				print node["everytime","code"]
				print "    end,"
				print "},"
			}
		}

		if ( subdialog != "" ) {
			print "------------------------------"
			print "-- " subdialog
			print "--"
			print "{"
			print "  topic = \"" subdialog "\","
			print "  generator = include(\"" subdialog "\"),"
			print "},"
			print "--"
			print "------------------------------\n"
		}
		
		for (i = 0 ; i <= 99 ; i++) {
			if ( (i,"text") in node ) {
				print "{"
				if (node[i,"comment"] != "") print node[i,"comment"]
				print "  id = \"" prefix "node" i "\","
				print "  text = " node[i,"text"] ","
				if (node[i,"no_echo"]) print "  echo_text = false,"
				if (node[i,"topic"]) print "  topic = " node[i,"topic"] ","
				print "  code = function()"
				print node[i,"code"]
				print "    end,"
				print "},"
			}
			if ( (i,"after") in node ) {
				subdialog = node[i,"after"]
				print "{"
				print "  -- called after the end of " subdialog " subdialog"
				print "  id = \"after-" subdialog "\","
				print "  code = function()"
				print "    pop_topic()"
				print node[subdialog,"code"]
				print "    end,"
				print "},"
			}
        }
        
		print "}";
	}
EOF

cat > $perl_script <<-"EOF"
	use strict;
	use warnings;

	use constant INDENT => '	';
	my($currIndent, $nextIndent, $prevLength) = (0, 0, 0);

	while (<>) {
	  chomp;
	  s/^\s+|\s+$//g; # remote all spaces on both ends
	  s/\s+/ /g; # replace all whitespaces inside the string with one space

	  my $orig = $_;

	  s/(['"])[^\1]*?\1//g; # remove all quoted fragments for proper bracket processing
	  s/\s*--.+//; # remove all comments; this ignores long bracket style comments

	  # open a level; increase next indentation; don't change current one
	  if (/^((local )?function|repeat|while)\b/ && !/\bend\s*[\),;]*$/
	   || /\b(then|do)$/ && !/^elseif\b/     # only open on 'then' if there is no 'elseif'
	   || /^if\b/ && /\bthen\b/ && !/\bend$/ # only open on 'if' if there is no 'end' at the end
	   || /\bfunction\s*\([^\)]*\)$/) {
	    $nextIndent = $currIndent + 1;
	  }
	  # close the level; change both current and next indentation
	  elsif (/^until\b/
	      || /^end\s*[\),;]*$/
	      || /^end\s*\)\s*\.\./ # this is a special case of 'end).."some string"'
	      || /^else(if)?\b/ && /\bend$/) {
	    $nextIndent = $currIndent = $currIndent - 1;
	  }
	  # keep the level; decrease the current indentation; keep the next one
	  elsif (/^else\b/
	      || /^elseif\b/) {
	    ($nextIndent, $currIndent) = ($currIndent, $currIndent-1);
	  }

	  my $brackets = y/(// - y/)//; # capture unbalanced brackets
	  my $curly = y/{// - y/}//; # capture unbalanced curly brackets

	  # close (curly) brackets if needed
	  $currIndent += $curly if $curly < 0 && /^\}/;
	  $currIndent += $brackets if $brackets < 0 && /^\)/;

	  warn "WARNING: negative indentation at line $.: $orig\n" if $currIndent < 0;

	  print((length($orig) ? (INDENT x $currIndent) : ''), $orig, "\n")
	    if $prevLength > 0 || length($orig) > 0; # this is to collapse empty lines

	  $nextIndent += $brackets + $curly;

	  $currIndent = $nextIndent;
	  $prevLength = length($orig);
	}

	warn "WARNING: positive indentation at the end\n" if $nextIndent > 0;
EOF

if [ ! -r $1 ] ; then
  echo "Can not read $1"
  exit 1
fi

dialog=$(basename $1 .dialog)
conv_flags=""

if [[ $(echo $dialog | grep "_sub$") ]] ; then
	conv_flags="-v prefix=$dialog"
fi

subdialog=$(grep "call_subdialog" $dialog.dialog | wc -l)
if [[ ($subdialog -ne 0) && ($subdialog -gt 1) ]] ; then
  echo "Can not handle dialogs calling more than one subdialog"
  exit 1
fi

gawk -f $awk_script $conv_flags $dialog.dialog > $dialog.conv
cat $dialog.conv | perl $perl_script > $dialog.lua

rm $awk_script
rm $perl_script
